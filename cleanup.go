package main

import (
	"bytes"
	"fmt"
	"net/url"
	"strings"
	"time"

	"github.com/rs/zerolog/log"
	"golang.org/x/crypto/ssh"
)

// cleanupBouncerAuditEntries connects to the UniFi Contoâ€œ via SSH,
// and runs a Mongo update that rewrites large admin_activity_log entries
// generated by cs-unifi-bouncer-* actions in the last 10 minutes.
func cleanupBouncerAuditEntries(unifiHost, unifiLogCleanupUser, unifiLogCleanupPassword string) error {
	host, err := extractHost(unifiHost)
	if err != nil {
		return fmt.Errorf("failed to extract host from URL: %w", err)
	}
	user := unifiLogCleanupUser
	password := unifiLogCleanupPassword
	tenMinutesAgo := time.Now().Add(-40 * time.Minute).UnixMilli()

	// Mongo command as a single line (no newlines)
	mongoCmd := fmt.Sprintf(
		`mongo ace --port 27117 --quiet --eval 'db.admin_activity_log.updateMany({ "meta.display_property_value": { $regex: "^cs-unifi-bouncer-" }, time: { $gt: %d } }, { $set: { updates: [ { property_path: "description", new_value: "Updated from bouncer" } ] } })'`,
		tenMinutesAgo,
	)

	log.Info().Msgf("Executing cleanup command on host %s", host)

	sshConfig := &ssh.ClientConfig{
		User: user,
		Auth: []ssh.AuthMethod{
			ssh.Password(password),
			ssh.KeyboardInteractive(func(user, instruction string, questions []string, echos []bool) ([]string, error) {
				out := make([]string, len(questions))
				for i := range questions {
					out[i] = password
				}
				return out, nil
			}),
		},
		HostKeyCallback: ssh.InsecureIgnoreHostKey(),
		Timeout:         5 * time.Second,
	}

	client, err := ssh.Dial("tcp", host+":22", sshConfig)
	if err != nil {
		return fmt.Errorf("failed to SSH: %w", err)
	}
	defer client.Close()

	session, err := client.NewSession()
	if err != nil {
		return fmt.Errorf("failed to create SSH session: %w", err)
	}
	defer session.Close()

	var outBuf, errBuf bytes.Buffer
	session.Stdout = &outBuf
	session.Stderr = &errBuf

	if err := session.Run(mongoCmd); err != nil {
		log.Info().Msgf("REMOTE STDOUT:\n%s", outBuf.String())
		log.Info().Msgf("REMOTE STDERR:\n%s", errBuf.String())
		return fmt.Errorf("mongo cleanup failed: %w", err)
	}

	log.Info().Msgf("Mongo cleanup completed successfully on %s\n%s", host, outBuf.String())
	return nil
}

func extractHost(ipURL string) (string, error) {
	// Ensure the URL has a scheme
	if !strings.Contains(ipURL, "://") {
		ipURL = "https://" + ipURL
	}

	u, err := url.Parse(ipURL)
	if err != nil {
		return "", err
	}

	// Strip port if present
	host := u.Host
	if strings.Contains(host, ":") {
		host = strings.Split(host, ":")[0]
	}

	return host, nil
}
